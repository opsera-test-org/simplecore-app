name: "ðŸš€ Bootstrap Infrastructure - simpson"

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type "bootstrap" to confirm infrastructure creation'
        required: true
        type: string

permissions:
  contents: write

env:
  APP_NAME: simpson
  TENANT: opsera
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  ARGOCD_SERVER: argocd-usw2.agent.opsera.dev

jobs:
  validate-input:
    name: "Validate Input"
    runs-on: ubuntu-latest
    steps:
      - name: Check Confirmation
        run: |
          if [ "${{ inputs.confirm }}" != "bootstrap" ]; then
            echo "âŒ Confirmation failed. Please type 'bootstrap' to proceed."
            exit 1
          fi
          echo "âœ… Confirmation received"

  create-ecr-repository:
    name: "Create ECR Repository"
    runs-on: ubuntu-latest
    needs: validate-input
    outputs:
      ecr_uri: ${{ steps.ecr.outputs.ecr_uri }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create ECR Repository
        id: ecr
        run: |
          REPO_NAME="${TENANT}/${APP_NAME}"

          if aws ecr describe-repositories --repository-names "$REPO_NAME" --region ${AWS_REGION} 2>/dev/null; then
            echo "âœ“ ECR repository already exists: $REPO_NAME"
          else
            aws ecr create-repository \
              --repository-name "$REPO_NAME" \
              --region ${AWS_REGION} \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256
            echo "âœ… Created ECR repository: $REPO_NAME"
          fi

          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${REPO_NAME}"
          echo "ecr_uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "ECR URI: $ECR_URI"

  setup-kubeconfig:
    name: "Setup Kubeconfig (Hub + Spoke)"
    runs-on: ubuntu-latest
    needs: validate-input
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Kubeconfig for Hub and Spoke
        run: |
          # Hub cluster (ArgoCD)
          aws eks update-kubeconfig \
            --name ${HUB_CLUSTER} \
            --region ${AWS_REGION} \
            --alias hub
          echo "âœ“ Hub cluster kubeconfig configured"

          # Spoke cluster (Application)
          aws eks update-kubeconfig \
            --name ${SPOKE_CLUSTER} \
            --region ${AWS_REGION} \
            --alias spoke
          echo "âœ“ Spoke cluster kubeconfig configured"

          # Verify contexts
          kubectl config get-contexts

  create-namespace:
    name: "Create Namespace on Spoke"
    runs-on: ubuntu-latest
    needs: setup-kubeconfig
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Kubeconfig
        run: |
          aws eks update-kubeconfig --name ${SPOKE_CLUSTER} --region ${AWS_REGION} --alias spoke

      - name: Create Namespace
        run: |
          NS="${TENANT}-${APP_NAME}-dev"

          if kubectl --context spoke get namespace $NS 2>/dev/null; then
            echo "âœ“ Namespace already exists: $NS"
          else
            kubectl --context spoke create namespace $NS
            kubectl --context spoke label namespace $NS \
              app=${APP_NAME} \
              tenant=${TENANT} \
              environment=dev
            echo "âœ… Created namespace: $NS"
          fi

  register-spoke-cluster:
    name: "Register Spoke Cluster with ArgoCD Hub"
    runs-on: ubuntu-latest
    needs: [setup-kubeconfig, create-namespace]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Kubeconfig
        run: |
          aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub
          aws eks update-kubeconfig --name ${SPOKE_CLUSTER} --region ${AWS_REGION} --alias spoke

      - name: Check if Spoke Already Registered
        id: check
        run: |
          if kubectl --context hub get secret -n argocd cluster-${SPOKE_CLUSTER} 2>/dev/null; then
            echo "âœ“ Spoke cluster already registered with ArgoCD"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "Spoke cluster not registered, will register now"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Register Spoke Cluster
        if: steps.check.outputs.skip != 'true'
        run: |
          # Get spoke cluster details
          SPOKE_CA=$(kubectl --context spoke config view --minify --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')
          SPOKE_SERVER=$(kubectl --context spoke config view --minify --raw -o jsonpath='{.clusters[0].cluster.server}')

          # Create service account token for ArgoCD
          cat <<EOF | kubectl --context spoke apply -f -
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: argocd-manager
            namespace: kube-system
          ---
          apiVersion: v1
          kind: Secret
          metadata:
            name: argocd-manager-token
            namespace: kube-system
            annotations:
              kubernetes.io/service-account.name: argocd-manager
          type: kubernetes.io/service-account-token
          ---
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRoleBinding
          metadata:
            name: argocd-manager-binding
          roleRef:
            apiGroup: rbac.authorization.k8s.io
            kind: ClusterRole
            name: cluster-admin
          subjects:
            - kind: ServiceAccount
              name: argocd-manager
              namespace: kube-system
          EOF

          # Wait for token to be created
          sleep 5

          SPOKE_TOKEN=$(kubectl --context spoke get secret -n kube-system argocd-manager-token -o jsonpath='{.data.token}' | base64 -d)

          # Create ArgoCD cluster secret on hub
          cat <<EOF | kubectl --context hub apply -f -
          apiVersion: v1
          kind: Secret
          metadata:
            name: cluster-${SPOKE_CLUSTER}
            namespace: argocd
            labels:
              argocd.argoproj.io/secret-type: cluster
          type: Opaque
          stringData:
            name: ${SPOKE_CLUSTER}
            server: ${SPOKE_SERVER}
            config: |
              {
                "bearerToken": "${SPOKE_TOKEN}",
                "tlsClientConfig": {
                  "insecure": false,
                  "caData": "${SPOKE_CA}"
                }
              }
          EOF

          echo "âœ… Spoke cluster registered with ArgoCD hub"

  create-repo-secret:
    name: "Create ArgoCD Repository Secret"
    runs-on: ubuntu-latest
    needs: [setup-kubeconfig, register-spoke-cluster]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Kubeconfig
        run: |
          aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub

      - name: Create Repository Secret
        run: |
          if kubectl --context hub get secret -n argocd repo-${APP_NAME} 2>/dev/null; then
            echo "âœ“ Repository secret already exists"
            exit 0
          fi

          cat <<EOF | kubectl --context hub apply -f -
          apiVersion: v1
          kind: Secret
          metadata:
            name: repo-${APP_NAME}
            namespace: argocd
            labels:
              argocd.argoproj.io/secret-type: repository
          type: Opaque
          stringData:
            type: git
            url: https://github.com/opsera-test-org/simplecore-app.git
            password: ${{ secrets.GH_PAT }}
            username: not-used
          EOF

          echo "âœ… Repository secret created"

  bootstrap-summary:
    name: "Bootstrap Summary"
    runs-on: ubuntu-latest
    needs: [create-ecr-repository, create-namespace, register-spoke-cluster, create-repo-secret]
    steps:
      - name: Display Summary
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          # ðŸŽ‰ Bootstrap Complete - simpson

          ## Infrastructure Created

          âœ… **ECR Repository**: ${{ needs.create-ecr-repository.outputs.ecr_uri }}
          âœ… **Namespace**: opsera-simpson-dev (on opsera-usw2-np)
          âœ… **Spoke Cluster**: Registered with ArgoCD hub
          âœ… **Repository Secret**: Created for GitHub access

          ## Next Steps

          1. **Set GitHub Variables**:
             ```bash
             gh variable set GITLEAKS_MODE --body "warn"
             gh variable set GRYPE_MODE --body "warn"
             ```

          2. **Trigger CI/CD**: Push to main branch or manually run:
             ```bash
             gh workflow run "2-cicd-dev-simpson.yaml"
             ```

          3. **Monitor Deployment**:
             - GitHub Actions: Check workflow run
             - ArgoCD: https://argocd-usw2.agent.opsera.dev
             - Application: http://simpson-dev.agent.opsera.dev

          EOF
