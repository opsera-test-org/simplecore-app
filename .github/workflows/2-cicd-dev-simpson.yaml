name: "üöÄ CI/CD Dev - simpson"

on:
  push:
    branches: [main]
    paths-ignore:
      - '.opsera-simpson/k8s/**'
      - '.github/workflows/**'
      - '**/*.md'
  workflow_dispatch:

permissions:
  contents: write
  security-events: write

env:
  APP_NAME: simpson
  TENANT: opsera
  ENV: dev
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  ARGOCD_SERVER: argocd-usw2.agent.opsera.dev
  APP_FOLDER: .opsera-simpson

concurrency:
  group: ci-simpson-dev-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # Stage 1: Security Scan (Gitleaks)
  security-scan:
    name: "üîí Security Scan (Gitleaks)"
    runs-on: ubuntu-latest
    continue-on-error: true  # Default to warn mode - change to false to block on secrets
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Display Scan Mode
        if: always()
        run: |
          if [ "${{ vars.GITLEAKS_MODE }}" = "warn" ]; then
            echo "‚ö†Ô∏è WARN MODE: Secrets detected but workflow continues"
          else
            echo "üö´ BLOCK MODE: Workflow failed due to secrets"
          fi

  # Stage 2: Build Image
  build-image:
    name: "üî® Build Image"
    runs-on: ubuntu-latest
    needs: security-scan
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
      image_name: ${{ steps.build.outputs.image_name }}
    steps:
      - uses: actions/checkout@v4

      - name: Generate Image Tag
        id: tag
        run: |
          IMAGE_TAG="${ENV}-${GITHUB_SHA:0:8}-$(date +%Y%m%d%H%M%S)"
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "Image tag: $IMAGE_TAG"

      - name: Build Docker Image
        id: build
        run: |
          IMAGE_TAG="${{ steps.tag.outputs.image_tag }}"
          docker build -t ${APP_NAME}:${IMAGE_TAG} .
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image_name=${APP_NAME}:${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "‚úÖ Image built: ${APP_NAME}:${IMAGE_TAG}"

      - name: Save Image to Artifact
        run: |
          IMAGE_TAG="${{ steps.tag.outputs.image_tag }}"
          docker save ${APP_NAME}:${IMAGE_TAG} -o /tmp/image.tar
          echo "‚úÖ Image saved to artifact"

      - name: Upload Image Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/image.tar
          retention-days: 1

  # Stage 3: Grype Vulnerability Scan
  grype-scan:
    name: "üîç Grype Vulnerability Scan"
    runs-on: ubuntu-latest
    needs: build-image
    continue-on-error: ${{ vars.GRYPE_MODE == 'warn' }}
    outputs:
      scan_passed: ${{ steps.scan.outputs.scan_passed }}
    steps:
      - name: Download Image Artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker Image
        run: |
          docker load -i /tmp/image.tar
          docker images
          echo "‚úÖ Image loaded"

      - name: Run Grype Scan
        id: scan
        run: |
          IMAGE_TAG="${{ needs.build-image.outputs.image_tag }}"
          IMAGE_NAME="${APP_NAME}:${IMAGE_TAG}"

          # Install Grype
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin

          # Run scan
          grype ${IMAGE_NAME} --fail-on high || {
            if [ "${{ vars.GRYPE_MODE }}" = "warn" ]; then
              echo "scan_passed=false" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è Vulnerabilities found but continuing (warn mode)"
              exit 0
            else
              echo "scan_passed=false" >> $GITHUB_OUTPUT
              echo "üö´ Vulnerabilities found - blocking deployment"
              exit 1
            fi
          }

          echo "scan_passed=true" >> $GITHUB_OUTPUT
          echo "‚úÖ No critical vulnerabilities found"

      - name: Display Scan Mode
        if: always()
        run: |
          if [ "${{ vars.GRYPE_MODE }}" = "warn" ]; then
            echo "‚ö†Ô∏è WARN MODE: Vulnerabilities reported but build continues"
          else
            echo "üö´ BLOCK MODE: Critical vulnerabilities block deployment"
          fi

  # Stage 4: Push to ECR
  push-to-ecr:
    name: "üì¶ Push to ECR"
    runs-on: ubuntu-latest
    needs: [build-image, grype-scan]
    outputs:
      ecr_uri: ${{ steps.push.outputs.ecr_uri }}
      image_tag: ${{ needs.build-image.outputs.image_tag }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download Image Artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker Image
        run: |
          docker load -i /tmp/image.tar
          echo "‚úÖ Image loaded"

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${AWS_REGION} | \
            docker login --username AWS --password-stdin \
            $(aws sts get-caller-identity --query Account --output text).dkr.ecr.${AWS_REGION}.amazonaws.com

      - name: Push to ECR
        id: push
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REPO="${TENANT}/${APP_NAME}"
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}"
          IMAGE_TAG="${{ needs.build-image.outputs.image_tag }}"

          # Tag for ECR
          docker tag ${APP_NAME}:${IMAGE_TAG} ${ECR_URI}:${IMAGE_TAG}
          docker tag ${APP_NAME}:${IMAGE_TAG} ${ECR_URI}:${ENV}-latest

          # Push both tags
          docker push ${ECR_URI}:${IMAGE_TAG}
          docker push ${ECR_URI}:${ENV}-latest

          echo "ecr_uri=${ECR_URI}" >> $GITHUB_OUTPUT
          echo "‚úÖ Pushed to ECR: ${ECR_URI}:${IMAGE_TAG}"

  # Stage 5: Update Manifests
  update-manifests:
    name: "üìù Update Manifests"
    runs-on: ubuntu-latest
    needs: push-to-ecr
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update Kustomization
        run: |
          KUSTOMIZATION="${APP_FOLDER}/k8s/overlays/${ENV}/kustomization.yaml"
          IMAGE_TAG="${{ needs.push-to-ecr.outputs.image_tag }}"
          ECR_URI="${{ needs.push-to-ecr.outputs.ecr_uri }}"

          echo "Updating: $KUSTOMIZATION"

          # RULE 196: Pull FIRST before modifications
          git pull --rebase origin ${GITHUB_REF_NAME}
          echo "‚úì Pulled latest changes"

          # RULE 203: Use sed with dynamic detection
          sed -i.bak "s|newName:.*${APP_NAME}.*|newName: ${ECR_URI}|g" "$KUSTOMIZATION"
          sed -i.bak "s|newTag:.*|newTag: ${IMAGE_TAG}|g" "$KUSTOMIZATION"
          rm -f "${KUSTOMIZATION}.bak"

          echo "‚úÖ Updated manifest"
          cat "$KUSTOMIZATION"

      - name: Commit and Push with Retry
        run: |
          KUSTOMIZATION="${APP_FOLDER}/k8s/overlays/${ENV}/kustomization.yaml"
          IMAGE_TAG="${{ needs.push-to-ecr.outputs.image_tag }}"

          # Stage changes
          git add "$KUSTOMIZATION"

          # Commit
          git commit -m "chore(deploy): update ${ENV} image to ${IMAGE_TAG} [skip ci]"

          # RULE 202: Retry loop for push
          for i in 1 2 3; do
            echo "Push attempt $i/3..."
            if git push origin ${GITHUB_REF_NAME}; then
              echo "‚úÖ Manifest updated and pushed successfully"
              break
            fi

            echo "‚ö†Ô∏è Push failed, pulling latest and retrying..."
            git pull --rebase origin ${GITHUB_REF_NAME}
            sleep 2

            if [ $i -eq 3 ]; then
              echo "‚ùå Failed to push after 3 attempts"
              exit 1
            fi
          done

  # Stage 6: Create/Update ArgoCD Application (MANDATORY - RULE 199)
  create-argocd-app:
    name: "üìã Create/Update ArgoCD App"
    runs-on: ubuntu-latest
    needs: update-manifests
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Kubeconfig
        run: |
          aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub

      - name: Create or Update ArgoCD Application
        run: |
          kubectl --context hub apply -f ${APP_FOLDER}/argocd/${ENV}/application.yaml
          kubectl --context hub get application ${APP_NAME}-${ENV} -n argocd
          echo "‚úÖ ArgoCD application created/updated"

  # Stage 7: Refresh ECR Secret
  refresh-ecr-secret:
    name: "üîê Refresh ECR Secret"
    runs-on: ubuntu-latest
    needs: [create-argocd-app, push-to-ecr]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Kubeconfig
        run: |
          aws eks update-kubeconfig --name ${SPOKE_CLUSTER} --region ${AWS_REGION} --alias spoke

      - name: Refresh ECR Pull Secret
        run: |
          NS="${TENANT}-${APP_NAME}-${ENV}"
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

          # RULE 197: Use --docker-password (NOT --docker-password-stdin)
          ECR_PASS=$(aws ecr get-login-password --region ${AWS_REGION})

          kubectl --context spoke create secret docker-registry ecr-pull-secret \
            --docker-server="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com" \
            --docker-username=AWS \
            --docker-password="$ECR_PASS" \
            --namespace="${NS}" \
            --dry-run=client -o yaml | kubectl --context spoke apply -f -

          echo "‚úÖ ECR secret refreshed (valid for 12 hours)"

  # Stage 8: Sync ArgoCD
  sync-argocd:
    name: "üîÑ Sync ArgoCD"
    runs-on: ubuntu-latest
    needs: [refresh-ecr-secret]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Kubeconfig
        run: |
          aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub

      - name: Hard Refresh ArgoCD
        run: |
          kubectl --context hub -n argocd patch app ${APP_NAME}-${ENV} \
            --type merge -p '{"operation":{"initiatedBy":{"username":"github-actions"},"info":[{"name":"Reason","value":"CI/CD deployment"}]}}'
          kubectl --context hub -n argocd annotate app ${APP_NAME}-${ENV} \
            argocd.argoproj.io/refresh=hard --overwrite
          echo "‚úÖ ArgoCD hard refresh triggered"

      - name: Sync and Wait
        run: |
          kubectl --context hub -n argocd patch app ${APP_NAME}-${ENV} \
            --type merge -p '{"operation":{"sync":{"revision":"main"}}}'

          echo "Waiting for sync to complete..."
          for i in {1..30}; do
            STATUS=$(kubectl --context hub -n argocd get app ${APP_NAME}-${ENV} -o jsonpath='{.status.sync.status}')
            HEALTH=$(kubectl --context hub -n argocd get app ${APP_NAME}-${ENV} -o jsonpath='{.status.health.status}')

            echo "Attempt $i/30 - Sync: $STATUS, Health: $HEALTH"

            if [ "$STATUS" = "Synced" ] && [ "$HEALTH" = "Healthy" ]; then
              echo "‚úÖ Application synced and healthy"
              exit 0
            fi

            sleep 10
          done

          echo "‚ö†Ô∏è Sync timeout - check ArgoCD manually"
          exit 1

  # Stage 9: Verify Deployment
  verify-deployment:
    name: "‚úÖ Verify Deployment"
    runs-on: ubuntu-latest
    needs: sync-argocd
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Kubeconfig
        run: |
          aws eks update-kubeconfig --name ${SPOKE_CLUSTER} --region ${AWS_REGION} --alias spoke

      - name: Verify Pods
        run: |
          NS="${TENANT}-${APP_NAME}-${ENV}"

          echo "Waiting for pods to be ready..."
          kubectl --context spoke wait --for=condition=ready pod \
            -l app=${APP_NAME} \
            -n ${NS} \
            --timeout=300s

          echo "‚úÖ All pods ready"
          kubectl --context spoke get pods -n ${NS} -l app=${APP_NAME}

      - name: Verify Service
        run: |
          NS="${TENANT}-${APP_NAME}-${ENV}"
          kubectl --context spoke get svc -n ${NS} ${APP_NAME}
          echo "‚úÖ Service verified"

      - name: Verify Ingress
        run: |
          NS="${TENANT}-${APP_NAME}-${ENV}"
          kubectl --context spoke get ingress -n ${NS} ${APP_NAME}
          echo "‚úÖ Ingress verified"

  # Stage 10: Deployment Summary
  deployment-summary:
    name: "üìä Deployment Summary"
    runs-on: ubuntu-latest
    needs: [verify-deployment, push-to-ecr]
    steps:
      - name: Generate Summary
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          # üéâ Deployment Complete - simpson (dev)

          ## Deployment Details

          - **Environment**: dev
          - **Image Tag**: ${{ needs.push-to-ecr.outputs.image_tag }}
          - **ECR URI**: ${{ needs.push-to-ecr.outputs.ecr_uri }}
          - **Namespace**: opsera-simpson-dev
          - **Cluster**: opsera-usw2-np

          ## Access

          - **Application URL**: http://simpson-dev.agent.opsera.dev
          - **ArgoCD**: https://argocd-usw2.agent.opsera.dev/applications/simpson-dev

          ## Pipeline Stages

          ‚úÖ Security Scan (Gitleaks)
          ‚úÖ Build Image
          ‚úÖ Vulnerability Scan (Grype)
          ‚úÖ Push to ECR
          ‚úÖ Update Manifests
          ‚úÖ Create ArgoCD App
          ‚úÖ Refresh ECR Secret
          ‚úÖ Sync ArgoCD
          ‚úÖ Verify Deployment
          ‚úÖ Generate Summary

          EOF

  # Stage 11: Trigger Landscape (MANDATORY - RULE 201)
  trigger-landscape:
    name: "üìä Trigger Deployment Landscape"
    runs-on: ubuntu-latest
    needs: [deployment-summary]
    if: success()
    steps:
      - name: Trigger Landscape Workflow
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
          script: |
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'deployment-landscape-simpson.yaml',
                ref: context.ref || 'main',
                inputs: {
                  environment: 'dev'
                }
              });
              console.log('‚úÖ Deployment landscape workflow triggered for dev');
            } catch (error) {
              console.log('‚ö†Ô∏è Could not trigger landscape workflow:', error.message);
              console.log('This is non-blocking - deployment succeeded');
            }
