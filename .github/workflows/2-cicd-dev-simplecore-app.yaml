name: "2-CI/CD Deploy - simplecore-app (dev)"

on:
  push:
    branches: [main]
    paths-ignore:
      - 'k8s/**'
      - '.github/workflows/*.yaml'
      - '**/*.md'
  workflow_dispatch:

env:
  APP_NAME: simplecore-app
  TENANT: opsera
  ENVIRONMENT: dev
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  NAMESPACE: opsera-simplecore-app-dev

concurrency:
  group: ci-${{ github.ref }}-simplecore-app-dev
  cancel-in-progress: false

jobs:
  security-scan:
    name: "ðŸ”’ Security Scan (Gitleaks)"
    runs-on: ubuntu-latest
    continue-on-error: true  # Quick Setup: warn mode by default
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Display Scan Mode
        if: always()
        run: echo "âš ï¸  WARN MODE: Secrets detected but workflow continues"

  build-image:
    name: "ðŸ—ï¸  Build Docker Image"
    runs-on: ubuntu-latest
    needs: [security-scan]
    if: always() && (needs.security-scan.result == 'success' || needs.security-scan.result == 'failure')
    outputs:
      image_tag: ${{ steps.tag.outputs.image_tag }}
      image_name: ${{ steps.tag.outputs.image_name }}
    steps:
      - uses: actions/checkout@v4

      - name: Generate Image Tag
        id: tag
        run: |
          IMAGE_TAG="${ENVIRONMENT}-${GITHUB_SHA:0:8}-$(date +%Y%m%d%H%M%S)"
          IMAGE_NAME="${APP_NAME}:${IMAGE_TAG}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "Building: ${IMAGE_NAME}"

      - name: Build Docker Image
        run: |
          docker build -t ${{ steps.tag.outputs.image_name }} .
          echo "âœ… Image built successfully"

      - name: Save Image as Artifact
        run: |
          docker save ${{ steps.tag.outputs.image_name }} -o /tmp/image.tar
          ls -lh /tmp/image.tar

      - name: Upload Image Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/image.tar
          retention-days: 1

  grype-scan:
    name: "ðŸ” Grype Vulnerability Scan"
    runs-on: ubuntu-latest
    needs: [build-image]
    continue-on-error: true  # Quick Setup: warn mode by default
    steps:
      - uses: actions/checkout@v4

      - name: Download Image Artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Load Docker Image
        run: |
          docker load -i image.tar
          docker images

      - name: Run Grype Scan
        uses: anchore/scan-action@v3
        id: grype
        with:
          image: ${{ needs.build-image.outputs.image_name }}
          fail-build: false
          severity-cutoff: high

      - name: Upload Grype Results
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: ${{ steps.grype.outputs.sarif }}

      - name: Display Scan Mode
        if: always()
        run: echo "âš ï¸  WARN MODE: Vulnerabilities reported but build continues"

  push-to-ecr:
    name: "ðŸ“¦ Push to ECR"
    runs-on: ubuntu-latest
    needs: [build-image, grype-scan]
    if: always() && needs.build-image.result == 'success'
    outputs:
      ecr_uri: ${{ steps.push.outputs.ecr_uri }}
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download Image Artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Load Docker Image
        run: docker load -i image.tar

      - name: Push to ECR
        id: push
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          ECR_URI="${ECR_REGISTRY}/${APP_NAME}"

          echo "ecr_uri=${ECR_URI}" >> $GITHUB_OUTPUT

          # Login to ECR
          aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}

          # Tag and push
          docker tag ${{ needs.build-image.outputs.image_name }} ${ECR_URI}:${{ needs.build-image.outputs.image_tag }}
          docker push ${ECR_URI}:${{ needs.build-image.outputs.image_tag }}

          echo "âœ… Image pushed: ${ECR_URI}:${{ needs.build-image.outputs.image_tag }}"

  refresh-ecr-secret:
    name: "ðŸ” Refresh ECR Pull Secret"
    runs-on: ubuntu-latest
    needs: [push-to-ecr]
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl for Spoke
        run: |
          aws eks update-kubeconfig --name ${SPOKE_CLUSTER} --region ${AWS_REGION} --alias spoke

      - name: Refresh ECR Secret
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

          # Get ECR password
          ECR_PASS=$(aws ecr get-login-password --region ${AWS_REGION})

          # Create/update secret (idempotent)
          kubectl create secret docker-registry ecr-pull-secret \
            --docker-server="${ECR_REGISTRY}" \
            --docker-username=AWS \
            --docker-password="$ECR_PASS" \
            --namespace="${NAMESPACE}" \
            --dry-run=client -o yaml | kubectl --context spoke apply -f -

          echo "âœ… ECR secret refreshed (valid for 12 hours)"

  update-manifests:
    name: "ðŸ“ Update Manifests"
    runs-on: ubuntu-latest
    needs: [push-to-ecr, build-image]
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Update and Commit Manifests
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Pull first to avoid conflicts (RULE 196)
          git pull --rebase origin ${GITHUB_REF_NAME}

          KUSTOMIZATION="k8s/overlays/dev/kustomization.yaml"
          IMAGE_TAG="${{ needs.build-image.outputs.image_tag }}"
          ECR_URI="${{ needs.push-to-ecr.outputs.ecr_uri }}"

          # Update kustomization.yaml using sed (RULE 203)
          sed -i.bak "s|newName:.*|newName: ${ECR_URI}|g" "$KUSTOMIZATION"
          sed -i.bak "s|newTag:.*|newTag: ${IMAGE_TAG}|g" "$KUSTOMIZATION"
          rm -f "${KUSTOMIZATION}.bak"

          echo "Updated kustomization.yaml:"
          cat "$KUSTOMIZATION"

          # Stage and commit
          git add "$KUSTOMIZATION"
          git commit -m "chore(deploy): update dev image to ${IMAGE_TAG} [skip ci]"

          # Push with retry loop (RULE 202)
          for i in 1 2 3; do
            echo "Push attempt $i/3..."
            if git push origin ${GITHUB_REF_NAME}; then
              echo "âœ… Manifest updated and pushed successfully"
              break
            fi

            echo "âš ï¸ Push failed, pulling latest and retrying..."
            git pull --rebase origin ${GITHUB_REF_NAME}
            sleep 2

            if [ $i -eq 3 ]; then
              echo "âŒ Failed to push after 3 attempts"
              exit 1
            fi
          done

  create-argocd-app:
    name: "ðŸŽ¯ Create/Update ArgoCD Application"
    runs-on: ubuntu-latest
    needs: [update-manifests]
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl for Hub
        run: |
          aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub

      - name: Create ArgoCD Application Manifest
        run: |
          mkdir -p /tmp/argocd
          cat > /tmp/argocd/application.yaml <<EOF
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: ${APP_NAME}-${ENVIRONMENT}
            namespace: argocd
          spec:
            project: default
            source:
              repoURL: https://github.com/${GITHUB_REPOSITORY}.git
              targetRevision: main
              path: k8s/overlays/${ENVIRONMENT}
            destination:
              name: ${SPOKE_CLUSTER}
              namespace: ${NAMESPACE}
            syncPolicy:
              automated:
                prune: true
                selfHeal: true
              syncOptions:
                - CreateNamespace=true
          EOF

      - name: Apply ArgoCD Application
        run: |
          kubectl --context hub apply -f /tmp/argocd/application.yaml
          echo "âœ… ArgoCD application created/updated"

  sync-argocd:
    name: "ðŸ”„ Sync ArgoCD"
    runs-on: ubuntu-latest
    needs: [create-argocd-app, refresh-ecr-secret]
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl for Hub
        run: |
          aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub

      - name: Hard Refresh and Sync
        run: |
          APP_NAME_FULL="${APP_NAME}-${ENVIRONMENT}"

          # Hard refresh
          kubectl --context hub patch app ${APP_NAME_FULL} -n argocd \
            --type merge -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'

          echo "Waiting for sync..."
          sleep 10

          # Trigger sync
          kubectl --context hub patch app ${APP_NAME_FULL} -n argocd \
            --type merge -p '{"operation":{"sync":{"syncStrategy":{"hook":{}}}}}'

          echo "âœ… ArgoCD sync triggered"

  verify-deployment:
    name: "âœ… Verify Deployment"
    runs-on: ubuntu-latest
    needs: [sync-argocd]
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl for Spoke
        run: |
          aws eks update-kubeconfig --name ${SPOKE_CLUSTER} --region ${AWS_REGION} --alias spoke

      - name: Wait for Rollout
        timeout-minutes: 5
        run: |
          echo "Waiting for deployment rollout..."
          kubectl --context spoke rollout status deployment/${APP_NAME} -n ${NAMESPACE} --timeout=5m
          echo "âœ… Deployment rolled out successfully"

      - name: Verify Pods
        run: |
          echo "Checking pod status..."
          kubectl --context spoke get pods -n ${NAMESPACE} -l app=${APP_NAME}

          # Wait for pods to be ready
          kubectl --context spoke wait --for=condition=ready pod -l app=${APP_NAME} -n ${NAMESPACE} --timeout=2m

          echo "âœ… All pods are ready"

      - name: Health Check
        run: |
          echo "Performing health check..."

          POD=$(kubectl --context spoke get pods -n ${NAMESPACE} -l app=${APP_NAME} -o jsonpath='{.items[0].metadata.name}')

          if [ -z "$POD" ]; then
            echo "âŒ No pods found"
            exit 1
          fi

          # Port-forward health check (RULE 168)
          kubectl --context spoke port-forward $POD 8081:8080 -n ${NAMESPACE} &
          PF_PID=$!
          sleep 3

          if wget -qO- http://localhost:8081/health; then
            echo "âœ… Health check passed"
          else
            echo "âš ï¸  Health check failed but deployment succeeded"
          fi

          kill $PF_PID 2>/dev/null || true

      - name: Display Access URL
        run: |
          echo "ðŸŽ‰ Deployment successful!"
          echo "Application URL: http://${APP_NAME}-${ENVIRONMENT}.agent.opsera.dev"

  deployment-summary:
    name: "ðŸ“Š Deployment Summary"
    runs-on: ubuntu-latest
    needs: [verify-deployment, build-image]
    if: always()
    steps:
      - name: Create Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # Deployment Summary: ${APP_NAME} (${ENVIRONMENT})

          ## âœ… Status: ${{ needs.verify-deployment.result == 'success' && 'SUCCESS' || 'FAILED' }}

          **Image Tag:** \`${{ needs.build-image.outputs.image_tag }}\`
          **Environment:** ${ENVIRONMENT}
          **Namespace:** ${NAMESPACE}
          **Cluster:** ${SPOKE_CLUSTER}

          **Access URL:** http://${APP_NAME}-${ENVIRONMENT}.agent.opsera.dev

          ---

          **Pipeline Stages:**
          - Security Scan: ${{ needs.security-scan.result }}
          - Build: ${{ needs.build-image.result }}
          - Grype Scan: ${{ needs.grype-scan.result }}
          - Push to ECR: ${{ needs.push-to-ecr.result }}
          - Update Manifests: ${{ needs.update-manifests.result }}
          - Sync ArgoCD: ${{ needs.sync-argocd.result }}
          - Verify: ${{ needs.verify-deployment.result }}

          **Commit:** ${GITHUB_SHA:0:8}
          **Branch:** ${GITHUB_REF_NAME}
          **Actor:** ${GITHUB_ACTOR}
          EOF
