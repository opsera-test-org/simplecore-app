name: "2-CI/CD Pipeline - simplecore14-dev"

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - '.github/workflows/1-bootstrap-*.yaml'

  workflow_dispatch:

env:
  TENANT: opsera
  APP_NAME: simplecore14
  ENV: dev
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  NAMESPACE: opsera-simplecore14-dev

permissions:
  contents: write
  id-token: write
  security-events: write

jobs:
  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # STAGE 1: SECRET SCANNING
  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  security-scan:
    name: "Stage 1: Security Scan (Gitleaks)"
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_ENABLE_UPLOAD_ARTIFACT: true
          GITLEAKS_ENABLE_SUMMARY: true

  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # STAGE 2: BUILD IMAGE (NO PUSH)
  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  build-image:
    name: "Stage 2: Build Docker Image"
    runs-on: ubuntu-latest
    needs: security-scan
    outputs:
      image_tag: ${{ steps.meta.outputs.version }}
      short_sha: ${{ steps.meta.outputs.short_sha }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Generate Image Metadata
        id: meta
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="${SHORT_SHA}-${TIMESTAMP}"
          echo "version=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "✓ Image tag: ${IMAGE_TAG}"

      - name: Build Docker Image (Local Only)
        run: |
          docker build -t ${{ env.APP_NAME }}:${{ steps.meta.outputs.version }} -f Dockerfile .
          echo "✓ Docker image built successfully"

      - name: Save Image as Artifact
        run: |
          mkdir -p /tmp/docker
          docker save ${{ env.APP_NAME }}:${{ steps.meta.outputs.version }} -o /tmp/docker/image.tar
          echo "✓ Image saved to artifact"

      - name: Upload Image Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/docker/image.tar
          retention-days: 1

  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # STAGE 3: GRYPE VULNERABILITY SCAN
  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  grype-scan:
    name: "Stage 3: Grype Vulnerability Scan"
    runs-on: ubuntu-latest
    needs: build-image
    continue-on-error: true
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Download Image Artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp/docker

      - name: Load Docker Image
        run: |
          docker load -i /tmp/docker/image.tar
          echo "✓ Image loaded"

      - name: Install Grype
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
          grype version

      - name: Run Grype Scan (Warn-Only Mode)
        run: |
          echo "Running vulnerability scan..."
          grype ${{ env.APP_NAME }}:${{ needs.build-image.outputs.image_tag }} \
            --fail-on high \
            -o json \
            --file grype-report.json || true

          echo "✓ Scan complete (warn-only mode)"

      - name: Generate SARIF Report
        if: always()
        run: |
          grype ${{ env.APP_NAME }}:${{ needs.build-image.outputs.image_tag }} \
            -o sarif \
            --file grype-report.sarif || true

      - name: Upload to GitHub Security
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: grype-report.sarif
          category: grype-container-scan

      - name: Upload Scan Reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: grype-scan-reports
          path: |
            grype-report.json
            grype-report.sarif
          retention-days: 30

  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # STAGE 4: PUSH TO ECR
  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  push-to-ecr:
    name: "Stage 4: Push to ECR"
    runs-on: ubuntu-latest
    needs: [build-image, grype-scan]
    if: always() && needs.build-image.result == 'success'
    outputs:
      ecr_image: ${{ steps.push.outputs.ecr_image }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS Account ID
        id: account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=${AWS_ACCOUNT_ID}" >> $GITHUB_OUTPUT

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin \
            ${{ steps.account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

      - name: Download Image Artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp/docker

      - name: Load and Push Image
        id: push
        run: |
          docker load -i /tmp/docker/image.tar

          ECR_REPO="${TENANT}-${APP_NAME}"
          ECR_URI="${{ steps.account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${ECR_REPO}"
          IMAGE_TAG="${{ needs.build-image.outputs.image_tag }}"

          docker tag ${APP_NAME}:${IMAGE_TAG} ${ECR_URI}:${IMAGE_TAG}
          docker push ${ECR_URI}:${IMAGE_TAG}

          echo "ecr_image=${ECR_URI}:${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "✓ Image pushed to ECR: ${ECR_URI}:${IMAGE_TAG}"

  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # STAGE 5: REFRESH ECR SECRET (SPOKE - BEFORE MANIFESTS!)
  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  refresh-ecr-secret:
    name: "Stage 5: Refresh ECR Secret (Spoke)"
    runs-on: ubuntu-latest
    needs: push-to-ecr
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure Spoke Cluster Access
        run: |
          aws eks update-kubeconfig --name ${SPOKE_CLUSTER} --region ${AWS_REGION} --alias spoke
          kubectl config use-context spoke

      - name: Refresh ECR Pull Secret
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_PASSWORD=$(aws ecr get-login-password --region ${AWS_REGION})
          ECR_SERVER="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

          kubectl delete secret ecr-pull-secret -n ${NAMESPACE} --ignore-not-found=true

          kubectl create secret docker-registry ecr-pull-secret \
            --docker-server=${ECR_SERVER} \
            --docker-username=AWS \
            --docker-password=${ECR_PASSWORD} \
            -n ${NAMESPACE}

          echo "✓ ECR pull secret refreshed in namespace: ${NAMESPACE}"

  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # STAGE 6: UPDATE MANIFESTS
  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  update-manifests:
    name: "Stage 6: Update Manifests"
    runs-on: ubuntu-latest
    needs: [push-to-ecr, refresh-ecr-secret]
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Pull Latest Changes
        run: |
          git pull --rebase origin main

      - name: Update Kustomization
        run: |
          ECR_IMAGE="${{ needs.push-to-ecr.outputs.ecr_image }}"
          KUSTOMIZATION_FILE=".opsera-${APP_NAME}/k8s/overlays/${ENV}/kustomization.yaml"

          # Replace image reference
          sed -i "s|newName:.*|newName: ${ECR_IMAGE%:*}|g" ${KUSTOMIZATION_FILE}
          sed -i "s|newTag:.*|newTag: ${{ needs.build-image.outputs.image_tag }}|g" ${KUSTOMIZATION_FILE}

          echo "✓ Kustomization updated with image: ${ECR_IMAGE}"

      - name: Commit and Push
        run: |
          git add .opsera-${APP_NAME}/k8s/overlays/${ENV}/kustomization.yaml

          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore(${ENV}): update image to ${{ needs.build-image.outputs.short_sha }} [skip ci]

          Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

            git push origin main
            echo "✓ Manifests committed and pushed"
          fi

  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # STAGE 6.5: CREATE/UPDATE ARGOCD APPLICATION (IDEMPOTENT)
  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  create-argocd-app:
    name: "Stage 6.5: Create ArgoCD Application"
    runs-on: ubuntu-latest
    needs: update-manifests
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure Hub Cluster Access
        run: |
          aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub
          kubectl config use-context hub

      - name: Create/Update ArgoCD Application (Idempotent)
        run: |
          APP_NAME_FULL="${TENANT}-${APP_NAME}-${ENV}"

          # Check if application exists
          if kubectl --context hub get application ${APP_NAME_FULL} -n argocd &>/dev/null; then
            echo "✓ ArgoCD application already exists: ${APP_NAME_FULL}"
          else
            echo "Creating ArgoCD application: ${APP_NAME_FULL}"
            kubectl --context hub apply -f .opsera-${APP_NAME}/argocd/${APP_NAME}-${ENV}-application.yaml
            echo "✓ ArgoCD application created: ${APP_NAME_FULL}"
          fi

  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # STAGE 7: ARGOCD HARD REFRESH (HUB)
  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  argocd-refresh:
    name: "Stage 7: ArgoCD Refresh (Hub)"
    runs-on: ubuntu-latest
    needs: create-argocd-app
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure Hub Cluster Access
        run: |
          aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub
          kubectl config use-context hub

      - name: Hard Refresh ArgoCD Application
        run: |
          APP_NAME_FULL="${TENANT}-${APP_NAME}-${ENV}"

          kubectl patch application ${APP_NAME_FULL} \
            -n argocd \
            --type json \
            -p='[{"op": "replace", "path": "/operation", "value": {"initiatedBy": {"username": "github-actions"}, "sync": {"revision": "HEAD"}}}]' || true

          echo "✓ ArgoCD application refreshed: ${APP_NAME_FULL}"

  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # STAGE 8: SYNC ARGOCD
  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  argocd-sync:
    name: "Stage 8: ArgoCD Sync"
    runs-on: ubuntu-latest
    needs: argocd-refresh
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure Hub Cluster Access
        run: |
          aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub
          kubectl config use-context hub

      - name: Trigger Sync and Wait
        run: |
          APP_NAME_FULL="${TENANT}-${APP_NAME}-${ENV}"

          kubectl patch application ${APP_NAME_FULL} \
            -n argocd \
            --type merge \
            -p '{"operation":{"initiatedBy":{"username":"github-actions"},"retry":{"limit":5}}}'

          echo "Waiting for sync to complete..."

          for i in {1..60}; do
            STATUS=$(kubectl get application ${APP_NAME_FULL} -n argocd -o jsonpath='{.status.sync.status}')
            HEALTH=$(kubectl get application ${APP_NAME_FULL} -n argocd -o jsonpath='{.status.health.status}')

            echo "Sync: ${STATUS}, Health: ${HEALTH}"

            if [ "$STATUS" = "Synced" ] && [ "$HEALTH" = "Healthy" ]; then
              echo "✓ Application synced and healthy!"
              exit 0
            fi

            sleep 10
          done

          echo "⚠️ Sync timeout - check ArgoCD for details"
          exit 1

  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # STAGE 9: VERIFY DEPLOYMENT (SPOKE)
  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  verify-deployment:
    name: "Stage 9: Verify Deployment"
    runs-on: ubuntu-latest
    needs: argocd-sync
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure Spoke Cluster Access
        run: |
          aws eks update-kubeconfig --name ${SPOKE_CLUSTER} --region ${AWS_REGION} --alias spoke
          kubectl config use-context spoke

      - name: Verify Pods
        run: |
          echo "Checking pod status..."
          kubectl get pods -n ${NAMESPACE} -l app=${APP_NAME}

          kubectl wait --for=condition=ready pod \
            -l app=${APP_NAME} \
            -n ${NAMESPACE} \
            --timeout=300s

          echo "✓ All pods are ready!"

      - name: Verify Service
        run: |
          kubectl get service ${APP_NAME} -n ${NAMESPACE}
          echo "✓ Service verified"

      - name: Verify Ingress
        run: |
          kubectl get ingress ${APP_NAME} -n ${NAMESPACE}
          INGRESS_HOST=$(kubectl get ingress ${APP_NAME} -n ${NAMESPACE} -o jsonpath='{.spec.rules[0].host}')
          echo "✓ Application URL: https://${INGRESS_HOST}"

  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # STAGE 10: DEPLOYMENT LANDSCAPE
  #━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  deployment-landscape:
    name: "Stage 10: Deployment Landscape"
    runs-on: ubuntu-latest
    needs: verify-deployment
    if: always() && needs.verify-deployment.result == 'success'
    steps:
      - name: Generate Deployment Summary
        run: |
          cat << EOF > deployment-summary.md
          # Deployment Summary - ${APP_NAME} (${ENV})

          **Status:** ✅ Deployed Successfully

          **Details:**
          - **Application:** ${APP_NAME}
          - **Environment:** ${ENV}
          - **Namespace:** ${NAMESPACE}
          - **Cluster:** ${SPOKE_CLUSTER}
          - **Region:** ${AWS_REGION}
          - **Image Tag:** ${{ needs.build-image.outputs.image_tag }}
          - **Commit:** ${{ github.sha }}
          - **Deployed By:** ${{ github.actor }}
          - **Timestamp:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")

          **Access:**
          - **URL:** https://${APP_NAME}-${ENV}.agent.opsera.dev

          **Pipeline Stages:**
          1. ✅ Security Scan (Gitleaks)
          2. ✅ Build Image
          3. ✅ Grype Vulnerability Scan
          4. ✅ Push to ECR
          5. ✅ Refresh ECR Secret
          6. ✅ Update Manifests
          7. ✅ ArgoCD Refresh
          8. ✅ ArgoCD Sync
          9. ✅ Verify Deployment
          10. ✅ Deployment Landscape
          EOF

          cat deployment-summary.md

      - name: Upload Deployment Landscape
        uses: actions/upload-artifact@v4
        with:
          name: deployment-landscape-${{ env.ENV }}
          path: deployment-summary.md
          retention-days: 30
