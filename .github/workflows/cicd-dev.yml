name: CI/CD Dev - simpcore1

on:
  push:
    branches:
      - main
    paths-ignore:
      - '.github/workflows/bootstrap-**'
      - 'README.md'
      - 'docs/**'
  workflow_dispatch:
    inputs:
      debug_mode:
        description: 'Enable debug mode'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      grype_mode:
        description: 'Grype scan mode'
        required: false
        default: 'warn'
        type: choice
        options:
          - 'warn'
          - 'block'

env:
  TENANT: opsera
  APP_NAME: simpcore1
  ENVIRONMENT: dev
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  ARGOCD_SERVER: argocd-usw2.agent.opsera.dev
  NAMESPACE: opsera-simpcore1-dev
  ECR_REPO_NAME: opsera/simpcore1
  GRYPE_MODE: ${{ inputs.grype_mode || 'warn' }}

jobs:
  security-scan:
    name: Security Scan (Gitleaks)
    runs-on: ubuntu-latest
    continue-on-error: true  # RULE 205: Warn-only by default
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-image:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [security-scan]
    permissions:
      contents: read
    outputs:
      image_tag: ${{ steps.generate_tag.outputs.image_tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate image tag
        id: generate_tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          IMAGE_TAG="${SHORT_SHA}-${TIMESTAMP}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Generated image tag: ${IMAGE_TAG}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image (local only, no push)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          tags: ${{ env.APP_NAME }}:${{ steps.generate_tag.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=/tmp/image.tar

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/image.tar
          retention-days: 1

  grype-scan:
    name: Grype Vulnerability Scan
    runs-on: ubuntu-latest
    needs: [build-image]
    permissions:
      contents: read
      security-events: write
    outputs:
      scan_passed: ${{ steps.scan.outputs.scan_passed }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker image
        run: |
          docker load --input /tmp/image.tar
          docker image ls

      - name: Install Grype
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin

      - name: Run Grype scan
        id: scan
        run: |
          IMAGE_NAME="${{ env.APP_NAME }}:${{ needs.build-image.outputs.image_tag }}"

          # Run scan and capture results
          if grype ${IMAGE_NAME} --fail-on high --output json > grype-results.json; then
            SCAN_STATUS="passed"
            echo "‚úì No high/critical vulnerabilities found"
          else
            SCAN_STATUS="failed"
            echo "‚ö†Ô∏è  High/critical vulnerabilities detected"
          fi

          # Generate reports
          grype ${IMAGE_NAME} --output table > grype-report.txt || true
          grype ${IMAGE_NAME} --output sarif > grype-sarif.json || true

          # Set outputs
          if [ "${{ env.GRYPE_MODE }}" == "warn" ]; then
            echo "scan_passed=true" >> $GITHUB_OUTPUT
            echo "Mode: warn-only - continuing despite vulnerabilities"
          else
            if [ "$SCAN_STATUS" == "passed" ]; then
              echo "scan_passed=true" >> $GITHUB_OUTPUT
            else
              echo "scan_passed=false" >> $GITHUB_OUTPUT
              echo "Mode: block - failing due to vulnerabilities"
              exit 1
            fi
          fi

      - name: Upload Grype results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: grype-results
          path: |
            grype-results.json
            grype-report.txt
            grype-sarif.json
          retention-days: 30

      - name: Upload SARIF to GitHub Security
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: grype-sarif.json

  push-to-ecr:
    name: Push to ECR
    runs-on: ubuntu-latest
    needs: [build-image, grype-scan]
    if: needs.grype-scan.outputs.scan_passed == 'true'
    permissions:
      contents: read
      id-token: write
    outputs:
      image_uri: ${{ steps.push.outputs.image_uri }}

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load and push Docker image
        id: push
        run: |
          docker load --input /tmp/image.tar

          ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
          IMAGE_TAG="${{ needs.build-image.outputs.image_tag }}"
          IMAGE_URI="${ECR_REGISTRY}/${{ env.ECR_REPO_NAME }}:${IMAGE_TAG}"

          docker tag ${{ env.APP_NAME }}:${IMAGE_TAG} ${IMAGE_URI}
          docker push ${IMAGE_URI}

          echo "image_uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "‚úì Pushed image: ${IMAGE_URI}"

  refresh-ecr-secret:
    name: Refresh ECR Secret (Spoke)
    runs-on: ubuntu-latest
    needs: [push-to-ecr]
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0'

      - name: Configure Spoke Cluster Access
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }} --alias spoke
          kubectl config use-context spoke

      - name: Get ECR login token
        id: ecr-token
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_PASSWORD=$(aws ecr get-login-password --region ${{ env.AWS_REGION }})
          echo "aws_account_id=${AWS_ACCOUNT_ID}" >> $GITHUB_OUTPUT
          echo "::add-mask::${ECR_PASSWORD}"
          echo "ecr_password=${ECR_PASSWORD}" >> $GITHUB_OUTPUT

      - name: Create or update ECR pull secret
        run: |
          kubectl --context spoke create secret docker-registry ecr-secret \
            --docker-server=${{ steps.ecr-token.outputs.aws_account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com \
            --docker-username=AWS \
            --docker-password="${{ steps.ecr-token.outputs.ecr_password }}" \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl --context spoke apply -f -

          echo "‚úì ECR secret refreshed in namespace: ${{ env.NAMESPACE }}"

  update-manifests:
    name: Update Kubernetes Manifests
    runs-on: ubuntu-latest
    needs: [push-to-ecr, refresh-ecr-secret]
    permissions:
      contents: write
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Update kustomization with new image
        run: |
          cd k8s/overlays/dev

          # Update image tag in kustomization.yaml
          IMAGE_URI="${{ needs.push-to-ecr.outputs.image_uri }}"

          if grep -q "newTag:" kustomization.yaml; then
            sed -i "s|newTag:.*|newTag: ${{ needs.build-image.outputs.image_tag }}|" kustomization.yaml
          else
            echo "Error: newTag not found in kustomization.yaml"
            exit 1
          fi

          echo "‚úì Updated image tag to: ${{ needs.build-image.outputs.image_tag }}"

      - name: Commit manifest changes (idempotent)
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Pull latest changes first
          git pull --rebase origin main || true

          # Check if there are changes to commit
          if git diff --quiet k8s/overlays/dev/kustomization.yaml; then
            echo "‚úì No changes to commit (already up to date)"
          else
            git add k8s/overlays/dev/kustomization.yaml
            git commit -m "Update dev image tag to ${{ needs.build-image.outputs.image_tag }} [skip ci]

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

            # Push with retry on conflict
            MAX_RETRIES=3
            RETRY=0
            while [ $RETRY -lt $MAX_RETRIES ]; do
              if git push origin main; then
                echo "‚úì Manifest changes pushed successfully"
                break
              else
                echo "Push failed, attempt $((RETRY+1))/$MAX_RETRIES"
                git pull --rebase origin main
                RETRY=$((RETRY+1))
              fi
            done
          fi

  validate-manifests:
    name: Validate Manifests (Fast-Fail)
    runs-on: ubuntu-latest
    needs: [update-manifests]
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0'

      - name: Install kustomize
        run: |
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/

      - name: Validate manifests with kubectl kustomize
        run: |
          cd k8s/overlays/dev
          echo "Validating manifests..."

          if kustomize build . > /tmp/manifests.yaml; then
            echo "‚úì Kustomize build successful"
          else
            echo "‚ùå Kustomize build failed"
            exit 1
          fi

          if kubectl apply --dry-run=client -f /tmp/manifests.yaml; then
            echo "‚úì Manifest validation successful (~30s fast-fail)"
          else
            echo "‚ùå Manifest validation failed"
            exit 1
          fi

  create-argocd-app:
    name: Create/Update ArgoCD Application
    runs-on: ubuntu-latest
    needs: [validate-manifests]
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0'

      - name: Configure Hub Cluster Access
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }} --alias hub
          kubectl config use-context hub

      - name: Create or update ArgoCD application
        run: |
          kubectl --context hub apply -f argocd/application-dev.yaml
          echo "‚úì ArgoCD application created/updated (idempotent)"

  argocd-refresh:
    name: ArgoCD Hard Refresh (Hub)
    runs-on: ubuntu-latest
    needs: [create-argocd-app]
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0'

      - name: Configure Hub Cluster Access
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }} --alias hub
          kubectl config use-context hub

      - name: Trigger ArgoCD hard refresh
        run: |
          kubectl --context hub patch application ${{ env.APP_NAME }}-dev \
            -n argocd \
            --type merge \
            -p '{"operation":{"initiatedBy":{"username":"github-actions"},"info":[{"name":"Reason","value":"New manifest commit"}]}}'

          kubectl --context hub patch application ${{ env.APP_NAME }}-dev \
            -n argocd \
            --type merge \
            -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'

          echo "‚úì ArgoCD hard refresh triggered"
          sleep 10

  sync-argocd:
    name: Sync ArgoCD Application
    runs-on: ubuntu-latest
    needs: [argocd-refresh]
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0'

      - name: Configure Hub Cluster Access
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }} --alias hub
          kubectl config use-context hub

      - name: Trigger ArgoCD sync
        run: |
          kubectl --context hub patch application ${{ env.APP_NAME }}-dev \
            -n argocd \
            --type merge \
            -p '{"operation":{"sync":{"syncStrategy":{"hook":{}}},"initiatedBy":{"username":"github-actions"}}}'

          echo "‚úì ArgoCD sync triggered"

      - name: Wait for sync completion
        timeout-minutes: 10
        run: |
          echo "Waiting for ArgoCD sync to complete..."

          for i in {1..60}; do
            SYNC_STATUS=$(kubectl --context hub get application ${{ env.APP_NAME }}-dev -n argocd -o jsonpath='{.status.sync.status}')
            HEALTH_STATUS=$(kubectl --context hub get application ${{ env.APP_NAME }}-dev -n argocd -o jsonpath='{.status.health.status}')

            echo "Sync: $SYNC_STATUS | Health: $HEALTH_STATUS"

            if [ "$SYNC_STATUS" == "Synced" ] && [ "$HEALTH_STATUS" == "Healthy" ]; then
              echo "‚úì ArgoCD sync completed successfully"
              exit 0
            fi

            sleep 10
          done

          echo "‚ùå ArgoCD sync timed out"
          kubectl --context hub get application ${{ env.APP_NAME }}-dev -n argocd -o yaml
          exit 1

  verify-deployment:
    name: Verify Deployment (Spoke)
    runs-on: ubuntu-latest
    needs: [sync-argocd]
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0'

      - name: Configure Spoke Cluster Access
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }} --alias spoke
          kubectl config use-context spoke

      - name: Check pod status
        timeout-minutes: 5
        run: |
          echo "Checking pod status..."

          kubectl --context spoke wait --for=condition=ready pod \
            -l app=${{ env.APP_NAME }} \
            -n ${{ env.NAMESPACE }} \
            --timeout=300s

          echo "‚úì All pods are ready"

      - name: Check deployment rollout
        run: |
          kubectl --context spoke rollout status deployment/${{ env.APP_NAME }} \
            -n ${{ env.NAMESPACE }} \
            --timeout=300s

          echo "‚úì Deployment rollout completed"

      - name: Verify health endpoint
        run: |
          POD_NAME=$(kubectl --context spoke get pod -l app=${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} -o jsonpath='{.items[0].metadata.name}')

          kubectl --context spoke exec ${POD_NAME} -n ${{ env.NAMESPACE }} -- wget -q -O- http://localhost:8080/health

          echo "‚úì Health endpoint responding"

      - name: Get deployment details
        run: |
          echo "=== Deployment Details ==="
          kubectl --context spoke get deployment/${{ env.APP_NAME }} -n ${{ env.NAMESPACE }}

          echo ""
          echo "=== Pods ==="
          kubectl --context spoke get pods -l app=${{ env.APP_NAME }} -n ${{ env.NAMESPACE }}

          echo ""
          echo "=== Service ==="
          kubectl --context spoke get svc/${{ env.APP_NAME }} -n ${{ env.NAMESPACE }}

  deployment-landscape:
    name: Generate Deployment Landscape
    runs-on: ubuntu-latest
    needs: [verify-deployment]
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate deployment summary
        run: |
          cat <<EOF > deployment-landscape.md
          # Deployment Landscape - ${{ env.APP_NAME }}

          **Environment:** ${{ env.ENVIRONMENT }}
          **Timestamp:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Commit:** ${{ github.sha }}
          **Image Tag:** ${{ needs.build-image.outputs.image_tag }}

          ## Deployment Details

          - **Namespace:** ${{ env.NAMESPACE }}
          - **Cluster:** ${{ env.SPOKE_CLUSTER }}
          - **Region:** ${{ env.AWS_REGION }}
          - **Image:** ${{ needs.push-to-ecr.outputs.image_uri }}

          ## Pipeline Stages

          ‚úÖ Security Scan (Gitleaks)
          ‚úÖ Build Docker Image
          ‚úÖ Grype Vulnerability Scan
          ‚úÖ Push to ECR
          ‚úÖ Refresh ECR Secret
          ‚úÖ Update Manifests
          ‚úÖ Validate Manifests
          ‚úÖ Create ArgoCD Application
          ‚úÖ ArgoCD Hard Refresh
          ‚úÖ Sync ArgoCD
          ‚úÖ Verify Deployment
          ‚úÖ Deployment Landscape

          ## Status

          üéâ **Deployment Successful!**

          EOF

          cat deployment-landscape.md

      - name: Upload deployment landscape
        uses: actions/upload-artifact@v4
        with:
          name: deployment-landscape
          path: deployment-landscape.md
          retention-days: 30
